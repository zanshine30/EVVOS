cat << 'EOF' | sudo tee /opt/evvos/evvos_voice.py > /dev/output
#!/usr/bin/env python3
"""
EVVOS PicoVoice Rhino Intent Recognition Service
Optimized for ReSpeaker 2-Mics Pi HAT V2.0 on Raspberry Pi Zero 2 W

This service listens for voice commands using PicoVoice Rhino
and provides RGB LED feedback via the ReSpeaker HAT.

Author: EVVOS Team
License: MIT
"""

import os
import sys
import time
import json
import logging
import signal
import struct
from datetime import datetime
from pathlib import Path

# Audio processing
import pyaudio
import pvrhino

# GPIO for LED control (ReSpeaker has APA102 RGB LEDs)
try:
    import spidev
    LEDS_AVAILABLE = True
except ImportError:
    LEDS_AVAILABLE = False
    print("[LED] Warning: spidev not available, LED control disabled")

# ============================================================================
# CONFIGURATION
# ============================================================================

# File paths
ACCESS_KEY_FILE = "/opt/evvos/picovoice_access_key.txt"
CONTEXT_FILE = "/opt/evvos/EVVOSVOICE_en_raspberry-pi_v4_0_0.rhn"
LOG_FILE = "/var/log/evvos-pico-voice.log"

# Audio configuration for ReSpeaker 2-Mics HAT
SAMPLE_RATE = 16000  # Rhino requires 16kHz
FRAME_LENGTH = 512   # Rhino frame length
CHANNELS = 1         # Mono for voice recognition
AUDIO_FORMAT = pyaudio.paInt16

# LED Colors (RGB)
LED_OFF = (0, 0, 0)
LED_LISTENING = (0, 128, 128)  # Cyan - waiting for input
LED_DETECTED = (0, 255, 0)      # Green - intent detected
LED_ERROR = (255, 0, 0)         # Red - error state
LED_PROCESSING = (128, 0, 128)  # Purple - processing

# ReSpeaker LED configuration (APA102)
LED_COUNT = 3  # ReSpeaker 2-Mics HAT has 3 LEDs

# ============================================================================
# LOGGING SETUP
# ============================================================================

# Setup dual logging (file + journalctl)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# ============================================================================
# LED CONTROL (APA102 via SPI)
# ============================================================================

class ReSpeakerLEDs:
    """Control ReSpeaker 2-Mics HAT APA102 RGB LEDs via SPI"""
    
    def __init__(self):
        self.enabled = LEDS_AVAILABLE
        self.spi = None
        
        if self.enabled:
            try:
                self.spi = spidev.SpiDev()
                self.spi.open(0, 0)  # SPI bus 0, device 0
                self.spi.max_speed_hz = 8000000  # 8MHz
                self.spi.mode = 0b01  # CPOL=0, CPHA=1
                logger.info("[LED] ReSpeaker LEDs initialized via SPI")
                self.set_all(LED_OFF)
            except Exception as e:
                logger.warning(f"[LED] Failed to initialize: {e}")
                self.enabled = False
    
    def _build_frame(self, brightness, r, g, b):
        """Build APA102 LED frame (32-bit)"""
        # APA102 format: [111][5-bit brightness][8-bit blue][8-bit green][8-bit red]
        return [
            0b11100000 | (brightness & 0x1F),  # Start frame + brightness
            b & 0xFF,  # Blue
            g & 0xFF,  # Green
            r & 0xFF   # Red
        ]
    
    def set_all(self, color, brightness=10):
        """Set all LEDs to the same color"""
        if not self.enabled or not self.spi:
            return
        
        try:
            r, g, b = color
            
            # APA102 protocol: start frame + LED frames + end frame
            data = [0x00, 0x00, 0x00, 0x00]  # Start frame
            
            for _ in range(LED_COUNT):
                data.extend(self._build_frame(brightness, r, g, b))
            
            data.extend([0xFF, 0xFF, 0xFF, 0xFF])  # End frame
            
            self.spi.xfer2(data)
        except Exception as e:
            logger.warning(f"[LED] Error setting LEDs: {e}")
    
    def pulse(self, color, duration=0.2):
        """Pulse effect (brief flash)"""
        if not self.enabled:
            return
        
        self.set_all(color, brightness=20)
        time.sleep(duration)
        self.set_all(LED_LISTENING, brightness=5)
    
    def cleanup(self):
        """Turn off LEDs and close SPI"""
        if self.spi:
            try:
                self.set_all(LED_OFF)
                self.spi.close()
                logger.info("[LED] LEDs turned off")
            except Exception as e:
                logger.warning(f"[LED] Cleanup error: {e}")

# ============================================================================
# PICOVOICE RHINO SERVICE
# ============================================================================

class PicoVoiceService:
    """Main PicoVoice Rhino service for voice intent recognition"""
    
    def __init__(self):
        self.running = False
        self.rhino = None
        self.audio_stream = None
        self.pa = None
        self.leds = ReSpeakerLEDs()
        self.access_key = None
        
        # Signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        logger.info("=" * 70)
        logger.info("EVVOS PicoVoice Rhino Service Starting")
        logger.info("=" * 70)
        logger.info(f"Python: {sys.version}")
        logger.info("PicoVoice Rhino: Installed")
        logger.info(f"Context: {CONTEXT_FILE}")
        logger.info(f"Sample Rate: {SAMPLE_RATE} Hz")
        logger.info(f"Frame Length: {FRAME_LENGTH}")
        logger.info("=" * 70)
    
    def signal_handler(self, signum, frame):
        """Handle shutdown signals"""
        logger.info(f"Received signal {signum}, shutting down...")
        self.running = False
    
    def load_access_key(self):
        """Load PicoVoice access key from file"""
        try:
            if not os.path.exists(ACCESS_KEY_FILE):
                logger.error(f"Access key file not found: {ACCESS_KEY_FILE}")
                logger.error("Create the file and add your PicoVoice access key")
                logger.error("Get a free key at: https://console.picovoice.ai")
                return False
            
            with open(ACCESS_KEY_FILE, 'r') as f:
                self.access_key = f.read().strip()
            
            if not self.access_key or self.access_key == "YOUR_ACCESS_KEY_HERE":
                logger.error("Invalid access key in file")
                logger.error("Please update the access key in: " + ACCESS_KEY_FILE)
                return False
            
            logger.info(f"Access key loaded: {self.access_key[:8]}...")
            return True
        
        except Exception as e:
            logger.error(f"Failed to load access key: {e}")
            return False
    
    def setup_rhino(self):
        """Initialize PicoVoice Rhino engine"""
        try:
            if not self.load_access_key():
                return False
            
            if not os.path.exists(CONTEXT_FILE):
                logger.error(f"Rhino context file not found: {CONTEXT_FILE}")
                return False
            
            logger.info("Initializing Rhino engine...")
            
            self.rhino = pvrhino.create(
                access_key=self.access_key,
                context_path=CONTEXT_FILE,
                require_endpoint=True  # Wait for speech endpoint before processing
            )
            
            logger.info("Rhino initialized successfully")
            logger.info(f"  Context: {self.rhino.context_info}")
            logger.info(f"  Frame Length: {self.rhino.frame_length}")
            logger.info(f"  Sample Rate: {self.rhino.sample_rate} Hz")
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to initialize Rhino: {e}")
            self.leds.set_all(LED_ERROR)
            return False
    
    def find_respeaker_device(self):
        """Find ReSpeaker audio input device index"""
        try:
            p = pyaudio.PyAudio()
            device_count = p.get_device_count()
            
            logger.info(f"Scanning {device_count} audio devices...")
            
            for i in range(device_count):
                info = p.get_device_info_by_index(i)
                device_name = info['name'].lower()
                
                if 'seeed' in device_name:
                    logger.info(f"Found ReSpeaker device:")
                    logger.info(f"  Index: {i}")
                    logger.info(f"  Name: {info['name']}")
                    logger.info(f"  Channels: {info['maxInputChannels']}")
                    logger.info(f"  Sample Rate: {info['defaultSampleRate']}")
                    p.terminate()
                    return i
            
            # If ReSpeaker not found, use default
            logger.warning("ReSpeaker not found by name, using default input")
            default_input = p.get_default_input_device_info()
            logger.info(f"Default input: {default_input['name']}")
            p.terminate()
            return None  # Use default
        
        except Exception as e:
            logger.error(f"Error finding audio device: {e}")
            return None
    
    def setup_audio_stream(self):
        """Initialize PyAudio stream for ReSpeaker microphone"""
        try:
            self.pa = pyaudio.PyAudio()
            
            # Find ReSpeaker device
            device_index = self.find_respeaker_device()
            
            logger.info("Opening audio stream...")
            
            # Open stream with ReSpeaker-optimized settings
            self.audio_stream = self.pa.open(
                input_device_index=device_index,
                rate=SAMPLE_RATE,
                channels=CHANNELS,
                format=AUDIO_FORMAT,
                input=True,
                frames_per_buffer=FRAME_LENGTH,
                stream_callback=None  # Blocking mode for better reliability
            )
            
            logger.info("Audio stream opened successfully")
            logger.info(f"  Device: {'ReSpeaker' if device_index else 'Default'}")
            logger.info(f"  Sample Rate: {SAMPLE_RATE} Hz")
            logger.info(f"  Channels: {CHANNELS} (Mono)")
            logger.info(f"  Frame Length: {FRAME_LENGTH}")
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to setup audio stream: {e}")
            self.leds.set_all(LED_ERROR)
            return False
    
    def process_voice_input(self):
        """Main loop: read audio and process with Rhino"""
        self.running = True
        logger.info("=" * 70)
        logger.info("Voice recognition active - listening for commands...")
        logger.info("=" * 70)
        
        # Set listening state
        self.leds.set_all(LED_LISTENING, brightness=5)
        
        frame_count = 0
        
        try:
            while self.running:
                # Read audio frame
                try:
                    pcm_data = self.audio_stream.read(
                        self.rhino.frame_length,
                        exception_on_overflow=False
                    )
                except Exception as e:
                    logger.warning(f"Audio read error: {e}")
                    time.sleep(0.1)
                    continue
                
                # Convert to 16-bit PCM
                pcm = struct.unpack_from(
                    "h" * self.rhino.frame_length,
                    pcm_data
                )
                
                # Process frame with Rhino
                is_finalized = self.rhino.process(pcm)
                
                frame_count += 1
                
                # Log heartbeat every 5 seconds
                if frame_count % (SAMPLE_RATE // FRAME_LENGTH * 5) == 0:
                    logger.info(f"[HEARTBEAT] Listening... ({frame_count} frames processed)")
                
                if is_finalized:
                    inference = self.rhino.get_inference()
                    
                    if inference.is_understood:
                        intent = inference.intent
                        slots = inference.slots
                        
                        logger.info("=" * 70)
                        logger.info(f"[INTENT DETECTED] Intent: '{intent}'")
                        logger.info(f"[SLOTS] {json.dumps(slots, indent=2)}")
                        logger.info("=" * 70)
                        
                        # LED feedback: Green pulse
                        self.leds.pulse(LED_DETECTED, duration=0.3)
                        
                        # Handle the detected intent
                        self.handle_intent(intent, slots)
                    
                    else:
                        logger.info("[SPEECH] Speech detected but no intent matched")
                        logger.info("  Try one of the configured commands")
        
        except KeyboardInterrupt:
            logger.info("Keyboard interrupt received")
        
        except Exception as e:
            logger.error(f"Error in voice processing loop: {e}", exc_info=True)
            self.leds.set_all(LED_ERROR)
        
        finally:
            self.cleanup()
    
    def handle_intent(self, intent, slots):
        """Handle detected intent and execute corresponding action"""
        logger.info(f"[ACTION] Processing intent: {intent}")
        
        # Map intents to actions
        if intent == "recording_control":
            logger.info("[ACTION] Recording control detected")
            # TODO: Integrate with EVVOS recording system
        
        elif intent == "emergency_action":
            logger.info("[ACTION] Emergency backup triggered!")
            # TODO: Trigger emergency backup
        
        elif intent == "incident_capture":
            logger.info("[ACTION] Capturing incident snapshot")
            # TODO: Trigger camera snapshot or screenshot
        
        elif intent == "user_confirmation":
            logger.info("[ACTION] User confirmation detected")
            # TODO: Handle confirm/cancel actions
        
        elif intent == "incident_mark":
            logger.info("[ACTION] Marking incident in timeline")
            # TODO: Add incident marker to recording
        
        else:
            logger.warning(f"[ACTION] Unknown intent: {intent}")
        
        # Optional: Send to Supabase Edge Function
        # self.send_to_backend(intent, slots)
    
    def send_to_backend(self, intent, slots):
        """Send intent data to EVVOS backend (optional)"""
        try:
            import requests
            
            # Replace with your Supabase Edge Function URL
            EDGE_FUNCTION_URL = os.getenv("EVVOS_EDGE_FUNCTION_URL")
            
            if not EDGE_FUNCTION_URL:
                return
            
            payload = {
                "intent": intent,
                "slots": slots,
                "timestamp": datetime.now().isoformat(),
                "device_id": os.getenv("EVVOS_DEVICE_ID", "unknown")
            }
            
            response = requests.post(
                EDGE_FUNCTION_URL,
                json=payload,
                timeout=5
            )
            
            if response.status_code == 200:
                logger.info("[BACKEND] Intent sent successfully")
            else:
                logger.warning(f"[BACKEND] Failed: {response.status_code}")
        
        except Exception as e:
            logger.warning(f"[BACKEND] Error sending intent: {e}")
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Shutting down voice recognition service...")
        
        if self.audio_stream:
            self.audio_stream.stop_stream()
            self.audio_stream.close()
            logger.info("Audio stream closed")
        
        if self.pa:
            self.pa.terminate()
            logger.info("PyAudio terminated")
        
        if self.rhino:
            self.rhino.delete()
            logger.info("Rhino engine released")
        
        self.leds.cleanup()
        
        logger.info("Voice recognition service shutdown complete")
        logger.info("=" * 70)
    
    def run(self):
        """Main service entry point"""
        if not self.setup_rhino():
            logger.error("Failed to initialize Rhino")
            return
        
        if not self.setup_audio_stream():
            logger.error("Failed to setup audio stream")
            return
        
        self.process_voice_input()

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

def main():
    try:
        service = PicoVoiceService()
        service.run()
    except Exception as e:
        logger.error(f"Unhandled exception: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()
EOF
