#!/bin/bash
# fix_picam_libx264.sh
#
# Targeted fix: replaces "-c:v", "copy" with libx264 re-encoding
# in /usr/local/bin/evvos-picam-tcp.py
#
# Run on the Pi:
#   curl -fsSL https://raw.githubusercontent.com/YOUR_USERNAME/YOUR_REPO/main/fix_picam_libx264.sh | sudo bash

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'#!/bin/bash
# fix_picam_mux.sh
#
# Injects the missing ffmpeg mux (H.264 + WAV → MP4) back into
# stop_recording_handler in /usr/local/bin/evvos-picam-tcp.py
#
# Run on the Pi:
#   curl -fsSL https://raw.githubusercontent.com/YOUR_USERNAME/YOUR_REPO/main/fix_picam_mux.sh | sudo bash

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
NC='\033[0m'

echo ""
echo -e "${CYAN}══════════════════════════════════════════════════${NC}"
echo -e "${CYAN}  EVVOS Pi Camera — Restore ffmpeg Mux            ${NC}"
echo -e "${CYAN}══════════════════════════════════════════════════${NC}"
echo ""

if [ "$EUID" -ne 0 ]; then
    echo -e "${RED}ERROR: Run as root: curl ... | sudo bash${NC}"
    exit 1
fi

SCRIPT_PATH="/usr/local/bin/evvos-picam-tcp.py"

if [ ! -f "$SCRIPT_PATH" ]; then
    echo -e "${RED}ERROR: $SCRIPT_PATH not found${NC}"
    exit 1
fi

BACKUP="${SCRIPT_PATH}.bak.$(date +%Y%m%d_%H%M%S)"
cp "$SCRIPT_PATH" "$BACKUP"
echo -e "${GREEN}✓ Backup: $BACKUP${NC}"

python3 << 'PYTHON_EOF'
import sys

SCRIPT_PATH = "/usr/local/bin/evvos-picam-tcp.py"

with open(SCRIPT_PATH) as fh:
    source = fh.read()

if 'libx264' in source:
    print("⚠ libx264 already present — nothing to do")
    sys.exit(0)

# ── Anchor: the unique comment line just before the response dict ─────────────
# This line is confirmed present in the current file.
ANCHOR = '            # Return comprehensive recording info for app to upload to Supabase\n            response = {'

if ANCHOR not in source:
    print("✗ Anchor string not found. Current file may differ.")
    print("  Looking for: '# Return comprehensive recording info...'")
    # Show lines around 'response = {' for diagnosis
    for i, line in enumerate(source.splitlines(), 1):
        if 'response = {' in line or 'Return comprehensive' in line:
            print(f"  Line {i}: {line}")
    sys.exit(1)

# ── Replacement: mux block + updated response dict ────────────────────────────
# Replaces from the anchor comment all the way through to (and including)
# the closing } of the response dict and the return statement.

OLD_BLOCK = '''\
            # Return comprehensive recording info for app to upload to Supabase
            response = {
                "status": "recording_stopped",
                "session_id": current_session_id,
                "video_path": str(current_video_path),
                "audio_path": str(current_audio_path),
                "video_filename": current_video_path.name,
                "audio_filename": current_audio_path.name,
                "video_size_bytes": video_size,
                "audio_size_bytes": audio_size,
                "video_size_mb": round(video_size / 1024 / 1024, 2),
                "audio_size_mb": round(audio_size / 1024 / 1024, 2),
                "pi_ip": pi_ip_address,
                "http_port": HTTP_PORT,
                # URLs for direct download from Pi (if needed)
                "video_url": f"http://{pi_ip_address}:{HTTP_PORT}/{current_video_path.name}" if pi_ip_address else None,
                "audio_url": f"http://{pi_ip_address}:{HTTP_PORT}/{current_audio_path.name}" if pi_ip_address else None
            }
            print(f"[CAMERA] Session data ready for upload to Supabase")
            return response'''

NEW_BLOCK = '''\
            # ── ffmpeg: mux H.264 + WAV → MP4 ───────────────────────────────
            # Use libx264 re-encoding (NOT -c:v copy) because picamera2 raw
            # H.264 has no PTS/DTS timestamps — copy produces an unplayable MP4.
            # ultrafast preset adds ~2-3s processing for a 5-min clip.
            mp4_path = current_video_path.with_suffix('.mp4')
            mp4_size = 0

            if current_video_path.exists() and current_audio_path.exists():
                print(f"[FFMPEG] Muxing H.264 + WAV → {mp4_path.name} ...")
                ffmpeg_cmd = [
                    "ffmpeg", "-y",
                    "-i", str(current_video_path),
                    "-i", str(current_audio_path),
                    "-c:v", "libx264",
                    "-preset", "ultrafast",
                    "-crf", "28",
                    "-c:a", "aac",
                    "-movflags", "+faststart",
                    "-loglevel", "error",
                    str(mp4_path)
                ]
                result = subprocess.run(ffmpeg_cmd, capture_output=True, text=True, timeout=120)
                if result.returncode != 0:
                    print(f"[FFMPEG] ERROR: {result.stderr.strip()}", file=sys.stderr)
                    print(f"[FFMPEG] Falling back to raw H.264")
                    mp4_path = current_video_path
                else:
                    mp4_size = mp4_path.stat().st_size if mp4_path.exists() else 0
                    print(f"[FFMPEG] ✓ MP4 created: {mp4_path.name} ({mp4_size / 1024 / 1024:.2f} MB)")
                    try:
                        current_video_path.unlink(missing_ok=True)
                        current_audio_path.unlink(missing_ok=True)
                        print(f"[FFMPEG] ✓ Cleaned up raw source files")
                    except Exception as cleanup_err:
                        print(f"[FFMPEG] Warning: could not delete raw files: {cleanup_err}")

            elif current_video_path.exists():
                print(f"[FFMPEG] Audio missing — muxing video-only MP4 ...")
                ffmpeg_cmd = [
                    "ffmpeg", "-y",
                    "-i", str(current_video_path),
                    "-c:v", "libx264",
                    "-preset", "ultrafast",
                    "-crf", "28",
                    "-an",
                    "-movflags", "+faststart",
                    "-loglevel", "error",
                    str(mp4_path)
                ]
                result = subprocess.run(ffmpeg_cmd, capture_output=True, text=True, timeout=120)
                if result.returncode != 0:
                    print(f"[FFMPEG] ERROR: {result.stderr.strip()}", file=sys.stderr)
                    mp4_path = current_video_path
                else:
                    mp4_size = mp4_path.stat().st_size if mp4_path.exists() else 0
                    print(f"[FFMPEG] ✓ Video-only MP4 created ({mp4_size / 1024 / 1024:.2f} MB)")
                    try:
                        current_video_path.unlink(missing_ok=True)
                    except Exception:
                        pass
            else:
                print(f"[FFMPEG] No video file found — skipping mux")
                mp4_path = current_video_path

            final_size = mp4_path.stat().st_size if mp4_path.exists() else 0

            response = {
                "status": "recording_stopped",
                "session_id": current_session_id,
                "video_path": str(mp4_path),
                "audio_path": str(current_audio_path),
                "video_filename": mp4_path.name,
                "audio_filename": current_audio_path.name,
                "video_size_bytes": final_size,
                "audio_size_bytes": audio_size,
                "video_size_mb": round(final_size / 1024 / 1024, 2),
                "audio_size_mb": round(audio_size / 1024 / 1024, 2),
                "pi_ip": pi_ip_address,
                "http_port": HTTP_PORT,
                "video_url": f"http://{pi_ip_address}:{HTTP_PORT}/{mp4_path.name}" if pi_ip_address else None,
                "audio_url": f"http://{pi_ip_address}:{HTTP_PORT}/{current_audio_path.name}" if pi_ip_address else None,
            }
            print(f"[CAMERA] Session ready — {mp4_path.name} ({final_size / 1024 / 1024:.2f} MB)")
            return response'''

if OLD_BLOCK not in source:
    print("✗ Could not find the full response block to replace.")
    print("  The file may have been partially modified.")
    print("  Trying anchor-only match to diagnose...")
    # Show what's around the anchor
    idx = source.find('# Return comprehensive recording info')
    if idx != -1:
        print(f"  Found anchor at char {idx}. Context:")
        print(source[idx:idx+500])
    sys.exit(1)

new_source = source.replace(OLD_BLOCK, NEW_BLOCK, 1)
print("✓ ffmpeg mux block injected into stop_recording_handler")
print("  Using libx264 re-encoding for guaranteed valid MP4")

with open(SCRIPT_PATH, 'w') as fh:
    fh.write(new_source)

print(f"✓ Saved to {SCRIPT_PATH}")
PYTHON_EOF

EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
    echo ""
    echo -e "${RED}✗ Patch failed — restoring backup${NC}"
    cp "$BACKUP" "$SCRIPT_PATH"
    exit $EXIT_CODE
fi

# Verify
echo ""
if grep -q 'libx264' "$SCRIPT_PATH"; then
    echo -e "${GREEN}✓ libx264 confirmed in script${NC}"
else
    echo -e "${RED}✗ libx264 NOT found — patch may have failed${NC}"
    exit 1
fi

echo ""
echo "↻ Restarting evvos-picam-tcp..."
systemctl restart evvos-picam-tcp.service
echo -e "${GREEN}✓ Service restarted${NC}"

echo ""
echo -e "${GREEN}══════════════════════════════════════════════════${NC}"
echo -e "${GREEN}✓ Done! ffmpeg mux restored with libx264          ${NC}"
echo -e "${GREEN}══════════════════════════════════════════════════${NC}"
echo ""
echo "Watch next recording: sudo journalctl -u evvos-picam-tcp -f"
echo "Look for: [FFMPEG] ✓ MP4 created"
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo ""
echo -e "${CYAN}══════════════════════════════════════════════════${NC}"
echo -e "${CYAN}  EVVOS Pi Camera — libx264 Fix                   ${NC}"
echo -e "${CYAN}══════════════════════════════════════════════════${NC}"
echo ""

if [ "$EUID" -ne 0 ]; then
    echo -e "${RED}ERROR: Run as root: curl ... | sudo bash${NC}"
    exit 1
fi

SCRIPT_PATH="/usr/local/bin/evvos-picam-tcp.py"

if [ ! -f "$SCRIPT_PATH" ]; then
    echo -e "${RED}ERROR: $SCRIPT_PATH not found${NC}"
    exit 1
fi

BACKUP="${SCRIPT_PATH}.bak.$(date +%Y%m%d_%H%M%S)"
cp "$SCRIPT_PATH" "$BACKUP"
echo -e "${GREEN}✓ Backup: $BACKUP${NC}"

# ── Diagnose: show every ffmpeg-related line ──────────────────────────────────
echo ""
echo -e "${YELLOW}All ffmpeg-related lines currently in script:${NC}"
grep -n 'ffmpeg\|"-c:v"\|"-c:a"\|"-i"\|copy\|libx264\|framerate\|preset\|faststart\|mp4_path' \
    "$SCRIPT_PATH" || echo "(none found)"
echo ""

# ── Apply fix in Python ───────────────────────────────────────────────────────

python3 << 'PYTHON_EOF'
import sys

SCRIPT_PATH = "/usr/local/bin/evvos-picam-tcp.py"

with open(SCRIPT_PATH) as fh:
    lines = fh.readlines()

if any('libx264' in l for l in lines):
    print("⚠ libx264 already present — no changes needed")
    sys.exit(0)

new_lines = []
i = 0
changes = 0

while i < len(lines):
    line = lines[i]
    stripped = line.strip()

    # ── Remove any -framerate lines added by previous patches ─────────────
    if '"-framerate"' in stripped or "'-framerate'" in stripped:
        print(f"  Removed stale -framerate line: {stripped}")
        i += 1
        continue

    # ── Replace: "-c:v", "copy",  →  libx264 block ───────────────────────
    # This is the one line that is always present regardless of patching history.
    if ('"-c:v"' in stripped or "'-c:v'" in stripped) and \
       ('"copy"' in stripped or "'copy'" in stripped):

        indent = len(line) - len(line.lstrip())
        pad = ' ' * indent

        # Check whether to use single or double quotes (match the file style)
        q = '"'

        new_lines.append(f'{pad}{q}-c:v{q}, {q}libx264{q},\n')
        new_lines.append(f'{pad}{q}-preset{q}, {q}ultrafast{q},\n')
        new_lines.append(f'{pad}{q}-crf{q}, {q}28{q},\n')
        changes += 1
        print(f"  Replaced '-c:v copy' with libx264 at line {i+1}")
        i += 1
        continue

    new_lines.append(line)
    i += 1

if changes == 0:
    print("⚠ No '-c:v', 'copy' lines found.")
    print("  Check the grep output above — the line may use different formatting.")
    sys.exit(1)

with open(SCRIPT_PATH, 'w') as fh:
    fh.writelines(new_lines)

print(f"\n✓ {changes} replacement(s) made — script saved")
PYTHON_EOF

EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
    echo ""
    echo -e "${RED}✗ Patch failed — restoring backup${NC}"
    cp "$BACKUP" "$SCRIPT_PATH"
    exit $EXIT_CODE
fi

# ── Verify ────────────────────────────────────────────────────────────────────
echo ""
echo -e "${YELLOW}ffmpeg lines after patch:${NC}"
grep -n 'ffmpeg\|"-c:v"\|"-c:a"\|"-i"\|libx264\|preset\|crf\|faststart' \
    "$SCRIPT_PATH" || echo "(none found)"
echo ""

echo "↻ Restarting evvos-picam-tcp..."
systemctl restart evvos-picam-tcp.service
echo -e "${GREEN}✓ Service restarted${NC}"

echo ""
echo -e "${GREEN}══════════════════════════════════════════════════${NC}"
echo -e "${GREEN}✓ Done! Pi will now re-encode video with libx264  ${NC}"
echo -e "${GREEN}  Valid MP4 guaranteed — players will open it.    ${NC}"
echo -e "${GREEN}══════════════════════════════════════════════════${NC}"
echo ""
echo "Watch logs: sudo journalctl -u evvos-picam-tcp -f"
