#!/bin/bash
# ============================================================================
# EVVOS Audio Fix — Shared Microphone (dsnoop exclusive lock fix)
#
# Problem:
#   PyAudio/PortAudio opens the ReSpeaker by hardware index (hw:X,0) rather
#   than through the dsnoop virtual device, holding an exclusive OS-level lock.
#   dsnoop cannot acquire that lock, so `arecord -D mic_shared` fails
#   silently and no audio file is written.
#
# Fix (two-part):
#   1. Force the voice service to open audio via the ALSA default device
#      (which /etc/asound.conf routes to mic_shared / dsnoop) instead of
#      scanning by hardware name. Belt-and-suspenders: also set AUDIODEV and
#      ALSA_PCM_DEVICE in the systemd unit.
#   2. Make arecord in the camera service print its stderr to the camera log
#      so failures are visible, not silent.
#
# Usage: sudo bash fix_shared_audio.sh
# ============================================================================

set -e

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
BLUE='\033[0;34m'; CYAN='\033[0;36m'; NC='\033[0m'

log_info()    { echo -e "${BLUE}ℹ${NC}  $1"; }
log_success() { echo -e "${GREEN}✓${NC}  $1"; }
log_warning() { echo -e "${YELLOW}⚠${NC}  $1"; }
log_error()   { echo -e "${RED}✗${NC}  $1"; }
log_section() {
    echo ""
    echo -e "${CYAN}════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}▶ $1${NC}"
    echo -e "${CYAN}════════════════════════════════════════════════════════${NC}"
}

[ "$EUID" -ne 0 ] && { log_error "Run as root: sudo bash fix_shared_audio.sh"; exit 1; }

VOICE_SCRIPT="/usr/local/bin/evvos-pico-voice-service.py"
CAM_SCRIPT="/usr/local/bin/evvos-picam-tcp.py"
VOICE_SERVICE="/etc/systemd/system/evvos-pico-voice.service"

[ -f "$VOICE_SCRIPT"  ] || { log_error "Missing: $VOICE_SCRIPT";  exit 1; }
[ -f "$CAM_SCRIPT"    ] || { log_error "Missing: $CAM_SCRIPT";    exit 1; }
[ -f "$VOICE_SERVICE" ] || { log_error "Missing: $VOICE_SERVICE"; exit 1; }

# ── Auto-detect card ──────────────────────────────────────────────────────────
CARD_INFO=$(aplay -l 2>/dev/null | grep -i seeed | head -1)
[ -z "$CARD_INFO" ] && { log_error "ReSpeaker not detected (aplay -l | grep seeed)"; exit 1; }
CARD_NUM=$(echo "$CARD_INFO" | grep -oP 'card \K[0-9]+')
CARD_HW=$(echo "$CARD_INFO" | grep -oP ': \K[^ ]+')
log_success "ReSpeaker detected: card $CARD_NUM ($CARD_HW)"

# ── Backup ────────────────────────────────────────────────────────────────────
BACKUP_DIR="/opt/evvos/backups/fix_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp "$VOICE_SCRIPT"  "$BACKUP_DIR/"
cp "$CAM_SCRIPT"    "$BACKUP_DIR/"
cp "$VOICE_SERVICE" "$BACKUP_DIR/"
log_success "Backups saved to $BACKUP_DIR"

# ============================================================================
# STEP 1 — Diagnose what is holding the hw device
# ============================================================================
log_section "Step 1: Diagnose Current Audio Device Usage"

log_info "Stopping services temporarily for clean diagnostic..."
systemctl stop evvos-pico-voice evvos-picam-tcp 2>/dev/null || true
sleep 2

log_info "Testing raw hw device (nothing should be holding it now):"
if timeout 3 arecord -D "hw:${CARD_NUM},0" -f S16_LE -r 16000 -c 2 -d 1 /tmp/diag_hw.wav 2>&1; then
    HW_SIZE=$(stat -c%s /tmp/diag_hw.wav 2>/dev/null || echo 0)
    rm -f /tmp/diag_hw.wav
    log_success "Raw hw device accessible when services are stopped ($HW_SIZE bytes)"
else
    log_error "Cannot access raw hw device even with services stopped"
    log_error "Check: fuser /dev/snd/pcmC${CARD_NUM}D0c"
fi

log_info "Testing dsnoop device (mic_shared):"
if timeout 3 arecord -D mic_shared -f S16_LE -r 16000 -c 2 -d 1 /tmp/diag_dsnoop.wav 2>&1; then
    DS_SIZE=$(stat -c%s /tmp/diag_dsnoop.wav 2>/dev/null || echo 0)
    rm -f /tmp/diag_dsnoop.wav
    log_success "dsnoop (mic_shared) accessible ($DS_SIZE bytes)"
else
    log_warning "dsnoop test failed — /etc/asound.conf may need refreshing"
fi

# ============================================================================
# STEP 2 — Rewrite /etc/asound.conf with explicit ipc_key and perm flags
# ============================================================================
log_section "Step 2: Rewrite /etc/asound.conf"

# Key change: ipc_perm 0666 allows all users/daemons to share the IPC segment.
# Previously missing this caused dsnoop to reject connections from root daemons
# running under different UIDs/sessions.

cat > /etc/asound.conf << ASOUND_EOF
# ── EVVOS Shared Audio — dsnoop multiplexer ────────────────────────────────
# Allows evvos-pico-voice (Rhino) and evvos-picam-tcp (arecord) to read
# from the same physical ReSpeaker microphone simultaneously.
# Generated by fix_shared_audio.sh

pcm.mic_shared {
    type dsnoop
    ipc_key 2048
    ipc_key_add_uid false
    ipc_perm 0666
    slave {
        pcm "hw:${CARD_NUM},0"
        channels 2
        rate 16000
        format S16_LE
        period_size 1024
        buffer_size 16384
    }
}

# Mono wrapper — plug converts stereo dsnoop → mono 16 kHz for voice recognition
pcm.mic_mono {
    type plug
    slave {
        pcm "mic_shared"
        channels 1
        rate 16000
        format S16_LE
    }
    route_policy "average"
}

# Default device: playback → hw speaker, capture → dsnoop
# This is what PyAudio uses when input_device_index=None (system default)
pcm.!default {
    type asym
    playback.pcm {
        type plug
        slave.pcm "hw:${CARD_NUM},0"
    }
    capture.pcm "mic_shared"
}

ctl.!default {
    type hw
    card ${CARD_NUM}
}
ASOUND_EOF

log_success "/etc/asound.conf rewritten with ipc_perm 0666"

# Verify dsnoop now works (services are stopped, hw is free)
log_info "Verifying dsnoop with services stopped..."
if timeout 4 arecord -D mic_shared -f S16_LE -r 16000 -c 2 -d 2 /tmp/verify_dsnoop.wav 2>&1; then
    V_SIZE=$(stat -c%s /tmp/verify_dsnoop.wav 2>/dev/null || echo 0)
    rm -f /tmp/verify_dsnoop.wav
    if [ "$V_SIZE" -gt 20000 ]; then
        log_success "dsnoop working correctly ($V_SIZE bytes)"
    else
        log_warning "dsnoop opened but file small — mic may be muted/low gain, but device sharing will work"
    fi
else
    log_error "dsnoop still failing. Check /etc/asound.conf and card number."
    log_error "Dump of current asound config:"
    cat /etc/asound.conf
    exit 1
fi

# ============================================================================
# STEP 3 — Fix voice service: open audio via ALSA default (→ dsnoop)
# ============================================================================
log_section "Step 3: Fix Voice Service Audio Device Selection"

# The real problem: PyAudio/PortAudio scans ALSA devices and opens the one
# with 'seeed' in its name — which is the raw hw device (exclusive lock).
# Fix: open PyAudio with input_device_index=None (system default device),
# which /etc/asound.conf routes to mic_shared (dsnoop). This is the only
# reliable way to ensure PortAudio uses the virtual dsnoop device.

python3 << 'VOICE_FIX_EOF'
path = "/usr/local/bin/evvos-pico-voice-service.py"
with open(path, "r") as f:
    src = f.read()

# ── Replace the entire setup_audio method ─────────────────────────────────────
# We search for the method by its def line and replace up to the return True/False.
# This is more resilient than exact full-body matching.

import re

NEW_SETUP_AUDIO = '''    def setup_audio(self):
        """
        Open the microphone via the ALSA system default device.

        /etc/asound.conf maps the default capture device to "mic_shared"
        (an ALSA dsnoop virtual device). dsnoop holds a single hardware lock
        on hw:CARD,0 and serves independent audio copies to every reader —
        so the camera service can run arecord simultaneously with no conflict.

        WHY input_device_index=None?
        Scanning by hardware name (e.g. 'seeed') returns the raw hw device
        which holds an exclusive OS-level lock. Using None lets PortAudio pick
        the ALSA default device, which /etc/asound.conf routes to dsnoop.
        """
        import ctypes, os

        # ── Suppress ALSA C-level noise ───────────────────────────────────────
        try:
            ERRORFN = ctypes.CFUNCTYPE(None, ctypes.c_char_p, ctypes.c_int,
                                       ctypes.c_char_p, ctypes.c_int, ctypes.c_char_p)
            _handler = ERRORFN(lambda *a: None)
            for lib in ('libasound.so.2', 'libasound.so'):
                try:
                    ctypes.cdll.LoadLibrary(lib).snd_lib_error_set_handler(_handler)
                    break
                except Exception:
                    pass
        except Exception:
            pass

        # ── Suppress ALSA stderr during PyAudio init ──────────────────────────
        devnull = saved_stderr = None
        try:
            devnull     = os.open(os.devnull, os.O_WRONLY)
            saved_stderr = os.dup(2)
            os.dup2(devnull, 2)
        except Exception:
            pass

        try:
            self.pa = pyaudio.PyAudio()
        finally:
            try:
                if saved_stderr is not None:
                    os.dup2(saved_stderr, 2)
                    os.close(saved_stderr)
                if devnull is not None:
                    os.close(devnull)
            except Exception:
                pass

        # ── Log all available devices for diagnosis ───────────────────────────
        logger.info("[AUDIO] Available PyAudio input devices:")
        for i in range(self.pa.get_device_count()):
            info = self.pa.get_device_info_by_index(i)
            if info['maxInputChannels'] > 0:
                logger.info(f"  [{i}] {info['name']}  channels={info['maxInputChannels']}  rate={int(info['defaultSampleRate'])}")

        # ── Open default device (→ dsnoop via /etc/asound.conf) ──────────────
        # input_device_index=None  →  PortAudio uses the ALSA 'default' PCM
        # which /etc/asound.conf maps to mic_shared (dsnoop).
        # This is the key change that allows simultaneous access.
        logger.info("[AUDIO] Opening default capture device (routed to mic_shared/dsnoop via /etc/asound.conf)...")
        try:
            self.audio_stream = self.pa.open(
                input_device_index=None,    # ← ALSA default = mic_shared (dsnoop)
                rate=SAMPLE_RATE,
                channels=CHANNELS,
                format=AUDIO_FORMAT,
                input=True,
                frames_per_buffer=FRAME_LENGTH,
            )
            # Identify which device was actually opened
            default_idx = self.pa.get_default_input_device_info()['index']
            default_name = self.pa.get_device_info_by_index(default_idx)['name']
            logger.info(f"[AUDIO] ✓ Stream opened via default device [{default_idx}] '{default_name}'")
            logger.info(f"[AUDIO]   Rate={SAMPLE_RATE} Hz  Channels={CHANNELS}  Frame={FRAME_LENGTH}")
            return True

        except Exception as e:
            logger.error(f"[AUDIO] Default device failed: {e}")
            logger.info("[AUDIO] Falling back to first available input device...")

            # Fallback: scan for any working input device
            for i in range(self.pa.get_device_count()):
                info = self.pa.get_device_info_by_index(i)
                if info['maxInputChannels'] < 1:
                    continue
                try:
                    self.audio_stream = self.pa.open(
                        input_device_index=i,
                        rate=SAMPLE_RATE,
                        channels=CHANNELS,
                        format=AUDIO_FORMAT,
                        input=True,
                        frames_per_buffer=FRAME_LENGTH,
                    )
                    logger.warning(f"[AUDIO] ⚠ Using fallback device [{i}] '{info['name']}'")
                    logger.warning("[AUDIO]   This may be the raw hw device (exclusive lock).")
                    logger.warning("[AUDIO]   Camera audio recording will likely fail.")
                    return True
                except Exception:
                    continue

            logger.error("[AUDIO] No working input device found")
            self.leds.set_all(LED_ERROR, brightness=20)
            return False
'''

# Find and replace setup_audio method
# Match from def setup_audio to the next def at class level (4-space indent)
pattern = r'(    def setup_audio\(self\):.*?)(?=\n    def )'
match = re.search(pattern, src, re.DOTALL)

if match:
    src = src[:match.start()] + NEW_SETUP_AUDIO + src[match.end():]
    print("✓ setup_audio method replaced via regex")
else:
    # Fallback: try direct string replacement of the def line area
    if "    def setup_audio(self):" in src:
        # Find start of method
        start_idx = src.index("    def setup_audio(self):")
        # Find start of next method at same indent level
        next_def = src.find("\n    def ", start_idx + 1)
        if next_def != -1:
            src = src[:start_idx] + NEW_SETUP_AUDIO + "\n" + src[next_def:]
            print("✓ setup_audio method replaced via index search")
        else:
            print("✗ Could not find end of setup_audio method")
            import sys; sys.exit(1)
    else:
        print("✗ setup_audio method not found in voice service")
        import sys; sys.exit(1)

with open(path, "w") as f:
    f.write(src)
print("Voice service saved.")
VOICE_FIX_EOF

log_success "Voice service patched (now uses ALSA default → dsnoop)"

# ============================================================================
# STEP 4 — Add AUDIODEV env var to voice service systemd unit
# ============================================================================
log_section "Step 4: Update Voice Service Systemd Unit"

# Belt-and-suspenders: set AUDIODEV=mic_shared in the systemd environment.
# Some PortAudio builds honour this env var to select the ALSA device string
# directly, bypassing the device index scan entirely.

if grep -q "AUDIODEV" "$VOICE_SERVICE"; then
    # Already has it — update the value
    sed -i 's|Environment=.*AUDIODEV.*|Environment="AUDIODEV=mic_shared" "ALSA_PCM_CARD=mic_shared"|' "$VOICE_SERVICE"
    log_info "Updated existing AUDIODEV in service unit"
else
    # Insert after the last Environment= line, or after [Service]
    if grep -q "^Environment=" "$VOICE_SERVICE"; then
        # Add after last Environment line
        sed -i '/^Environment=/a Environment="AUDIODEV=mic_shared"' "$VOICE_SERVICE"
    else
        # Add after [Service] section header
        sed -i '/^\[Service\]/a Environment="AUDIODEV=mic_shared"' "$VOICE_SERVICE"
    fi
    log_info "Added AUDIODEV=mic_shared to service unit"
fi

log_success "Systemd unit updated"

# ============================================================================
# STEP 5 — Fix camera service: capture arecord stderr so errors are visible
# ============================================================================
log_section "Step 5: Fix Camera Service arecord Error Logging"

python3 << 'CAM_FIX_EOF'
import re

path = "/usr/local/bin/evvos-picam-tcp.py"
with open(path, "r") as f:
    src = f.read()

# ── Fix 1: Capture arecord stderr instead of discarding it ───────────────────
# Replace: stderr=subprocess.PIPE  (from setup_shared_audio.sh patch)
# Or:      stderr=subprocess.DEVNULL  (from original)
# With:    stderr=subprocess.PIPE + log the output on failure

old_popen = '''            try:
                audio_process = subprocess.Popen(
                    audio_cmd,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.PIPE,
                )
                print(f"[AUDIO] arecord started (PID {audio_process.pid}) → {current_audio_path.name}")
            except Exception as ae:
                print(f"[AUDIO] WARNING: Could not start arecord: {ae}")
                print(f"[AUDIO]   Recording will continue VIDEO-ONLY (silent)")
                audio_process    = None
                current_audio_path = None'''

new_popen = '''            try:
                audio_process = subprocess.Popen(
                    audio_cmd,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.PIPE,   # captured so we can log errors
                )
                # Give arecord 1 second to either start writing or fail
                import time as _time
                _time.sleep(1.0)
                poll = audio_process.poll()
                if poll is not None:
                    # arecord already exited — capture why
                    stderr_out = audio_process.stderr.read().decode("utf-8", errors="replace").strip()
                    print(f"[AUDIO] ERROR: arecord exited immediately (code {poll})")
                    print(f"[AUDIO]   stderr: {stderr_out}")
                    print(f"[AUDIO]   Command: {' '.join(audio_cmd)}")
                    print(f"[AUDIO]   Recording will continue VIDEO-ONLY (silent)")
                    audio_process      = None
                    current_audio_path = None
                else:
                    print(f"[AUDIO] ✓ arecord running (PID {audio_process.pid}) → {current_audio_path.name}")
            except Exception as ae:
                print(f"[AUDIO] WARNING: Could not start arecord: {ae}")
                print(f"[AUDIO]   Command: {' '.join(audio_cmd)}")
                print(f"[AUDIO]   Recording will continue VIDEO-ONLY (silent)")
                audio_process      = None
                current_audio_path = None'''

# ── Fix 2: Log arecord stderr on stop as well ─────────────────────────────────
old_stop_wait = '''                if audio_process is not None:
                print(f"[AUDIO] Stopping arecord (PID {audio_process.pid})...")
                audio_process.terminate()
                try:
                    audio_process.wait(timeout=10)
                    print("[AUDIO] arecord stopped cleanly")
                except subprocess.TimeoutExpired:
                    audio_process.kill()
                    print("[AUDIO] arecord killed (did not stop within 10 s)")'''

new_stop_wait = '''                if audio_process is not None:
                print(f"[AUDIO] Stopping arecord (PID {audio_process.pid})...")
                audio_process.terminate()
                try:
                    audio_process.wait(timeout=10)
                    stderr_out = audio_process.stderr.read().decode("utf-8", errors="replace").strip()
                    if stderr_out:
                        print(f"[AUDIO] arecord stderr: {stderr_out}")
                    print("[AUDIO] arecord stopped cleanly")
                except subprocess.TimeoutExpired:
                    audio_process.kill()
                    print("[AUDIO] arecord killed (did not stop within 10 s)")'''

changed = False
if old_popen in src:
    src = src.replace(old_popen, new_popen)
    print("✓ arecord Popen block updated (stderr now visible)")
    changed = True
else:
    # It might already have the 1-second check from a previous run.
    # At minimum ensure stderr=subprocess.PIPE (not DEVNULL)
    if 'stderr=subprocess.DEVNULL' in src and 'audio_cmd' in src:
        # Find arecord Popen and update stderr
        src = src.replace(
            'stdout=subprocess.DEVNULL,\n                    stderr=subprocess.DEVNULL,',
            'stdout=subprocess.DEVNULL,\n                    stderr=subprocess.PIPE,   # captured for error logging',
            1
        )
        print("✓ arecord stderr changed from DEVNULL to PIPE")
        changed = True
    else:
        print("⚠ arecord Popen block not matched — stderr may already be correct")

if changed:
    with open(path, "w") as f:
        f.write(src)
    print("Camera service saved.")
else:
    print("No changes needed to camera service (arecord block already updated)")
CAM_FIX_EOF

log_success "Camera service arecord logging fixed"

# ============================================================================
# STEP 6 — Syntax check
# ============================================================================
log_section "Step 6: Syntax Check"

python3 -m py_compile "$VOICE_SCRIPT" \
    && log_success "Voice service syntax OK" \
    || { log_error "Syntax error in voice service — restoring backup"
         cp "$BACKUP_DIR/evvos-pico-voice-service.py" "$VOICE_SCRIPT"
         exit 1; }

python3 -m py_compile "$CAM_SCRIPT" \
    && log_success "Camera service syntax OK" \
    || { log_error "Syntax error in camera service — restoring backup"
         cp "$BACKUP_DIR/evvos-picam-tcp.py" "$CAM_SCRIPT"
         exit 1; }

# ============================================================================
# STEP 7 — Restart services and run simultaneous capture test
# ============================================================================
log_section "Step 7: Restart Services"

systemctl daemon-reload

log_info "Starting evvos-pico-voice..."
systemctl start evvos-pico-voice
sleep 4   # give PyAudio time to open the device

if systemctl is-active --quiet evvos-pico-voice; then
    log_success "evvos-pico-voice ✓ running"
    log_info "Checking logs for device opened..."
    journalctl -u evvos-pico-voice -n 15 --no-pager | grep -i "AUDIO\|dsnoop\|default\|error\|seeed" || true
else
    log_error "evvos-pico-voice failed to start"
    log_error "Last 20 log lines:"
    journalctl -u evvos-pico-voice -n 20 --no-pager
    exit 1
fi

log_info "Starting evvos-picam-tcp..."
systemctl start evvos-picam-tcp
sleep 2

if systemctl is-active --quiet evvos-picam-tcp; then
    log_success "evvos-picam-tcp ✓ running"
else
    log_error "evvos-picam-tcp failed to start"
    journalctl -u evvos-picam-tcp -n 20 --no-pager
    exit 1
fi

# ============================================================================
# STEP 8 — Simultaneous capture test (with voice service running)
# ============================================================================
log_section "Step 8: Simultaneous Capture Test (Voice Service Live)"

log_info "Testing arecord while evvos-pico-voice is running..."
log_info "(This is the real test — voice service holds the device open)"

ARECORD_ERR=$(mktemp)
if timeout 4 arecord -D mic_shared -f S16_LE -r 16000 -c 2 -d 2 /tmp/sim_test.wav 2>"$ARECORD_ERR"; then
    SIM_SIZE=$(stat -c%s /tmp/sim_test.wav 2>/dev/null || echo 0)
    rm -f /tmp/sim_test.wav
    if [ "$SIM_SIZE" -gt 20000 ]; then
        log_success "SUCCESS! Simultaneous capture works ($SIM_SIZE bytes)"
        log_success "Voice recognition and audio recording can now run in parallel."
    else
        log_warning "Device opened but file is small ($SIM_SIZE bytes)"
        log_warning "Audio data may be silence — check microphone gain:"
        log_warning "  sudo amixer -c $CARD_HW sset 'PGA' 25"
    fi
else
    ARECORD_STDERR=$(cat "$ARECORD_ERR")
    log_error "arecord STILL FAILING while voice service is running"
    log_error "arecord error output: $ARECORD_STDERR"
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "DIAGNOSIS: Voice service is NOT using dsnoop."
    echo "Check which device the voice service actually opened:"
    echo ""
    echo "  sudo journalctl -u evvos-pico-voice -n 30 --no-pager | grep AUDIO"
    echo ""
    echo "If you see 'seeed' instead of 'default' or 'mic_shared', the"
    echo "voice service is still opening the raw hw device."
    echo ""
    echo "Manual test (stop voice service first):"
    echo "  sudo systemctl stop evvos-pico-voice"
    echo "  arecord -D mic_shared -d 2 /tmp/test.wav"
    echo "  sudo systemctl start evvos-pico-voice"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
fi
rm -f "$ARECORD_ERR"

# ============================================================================
# DONE
# ============================================================================
log_section "Fix Complete"

echo ""
echo -e "${CYAN}What changed:${NC}"
echo "  /etc/asound.conf          → rewritten with ipc_perm 0666"
echo "  evvos-pico-voice-service  → now opens ALSA default device (→ dsnoop)"
echo "  evvos-pico-voice.service  → AUDIODEV=mic_shared env var added"
echo "  evvos-picam-tcp           → arecord stderr now logged (not silenced)"
echo ""
echo -e "${CYAN}To verify after your next recording:${NC}"
echo "  sudo journalctl -u evvos-picam-tcp -f"
echo ""
echo "  You should see on START:"
echo "    [AUDIO] ✓ arecord running (PID XXXX) → audio_YYYYMMDD_HHMMSS.wav"
echo ""
echo "  You should see on STOP:"
echo "    [AUDIO] Audio file ready: audio_*.wav (XXXX KB)"
echo "    [FFMPEG] Encoding MP4 (audio=yes)"
echo "    [FFMPEG] ✓ video_*.mp4 (XX.XX MB, audio=yes)"
echo ""
echo -e "${CYAN}If it still fails, run this to see the exact arecord error:${NC}"
echo "  sudo systemctl stop evvos-pico-voice"
echo "  arecord -D mic_shared -f S16_LE -r 16000 -c 2 -d 3 /tmp/test.wav"
echo "  sudo systemctl start evvos-pico-voice"
echo ""
